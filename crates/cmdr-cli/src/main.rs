use clap::Parser;
use rustyline::error::ReadlineError;
use rustyline::history::DefaultHistory;
use rustyline::Editor;
use std::process;

use cmdr_core::{TranslationEngine, MockInferenceEngine, ShellExecutor, NaturalLanguageRequest};
use cmdr_core::InferenceEngine;

/// cmdr - A fast, REPL-based command-line interface that translates natural language to shell commands
///
/// Phase 1 CLI Interface Contract:
///
/// Top-level flags (auto-generated by clap):
/// --help, -h     Display help information
/// --version, -V  Display version information
///
/// Phase 1 operational flags:
/// -c, --command <STRING>  Single-shot mode: translate and execute a single natural language command
/// --config <FILE>         Configuration file path (placeholder, not yet used in Phase 1)
///
/// Phase 2+ reserved functionality:
/// - Interactive REPL mode (default when no -c flag provided)
/// - Model selection and configuration options
/// - Inference backend selection (llama.cpp, mistral.rs, etc.)
///
/// Phase 3+ reserved functionality:
/// - Subcommands for advanced operations
/// - Plugin management
/// - History and session management
#[derive(Parser, Debug)]
#[command(
    name = "cmdr",
    version = env!("CMDR_VERSION"),
    author = "cmdr contributors",
    about = "A fast, REPL-based command-line interface that translates natural language to shell commands"
)]
struct Args {
    /// Single-shot mode: translate and execute a single natural language command
    #[arg(short = 'c', long = "command", value_name = "STRING")]
    command: Option<String>,

    /// Configuration file path (placeholder, not yet used)
    #[arg(long = "config", value_name = "FILE")]
    config: Option<String>,
}

fn main() {
    let args = Args::parse();

    // Fast-path execution logic for mature UNIX tool behavior

    // Handle -c/--command fast-path
    if let Some(command) = args.command {
        match execute_single_command(&command) {
            Ok(_) => process::exit(0),
            Err(e) => {
                eprintln!("Error: {}", e);
                process::exit(1);
            }
        }
    }

    // Handle --config (placeholder for Phase 2)
    if let Some(config_file) = args.config {
        println!("Configuration file specified: {config_file}");
        // TODO: Implement configuration file parsing in Phase 2
        println!("Configuration loading not yet implemented");
    }

    // Interactive REPL mode
    run_repl();
}

fn execute_single_command(natural_language: &str) -> anyhow::Result<()> {
    let mut inference_engine = MockInferenceEngine::new();
    inference_engine.initialize()?;
    inference_engine.load_model("mock-model")?;
    
    let mut translation_engine = TranslationEngine::new(inference_engine);
    let shell_executor = ShellExecutor::default();
    
    let request = NaturalLanguageRequest {
        text: natural_language.to_string(),
        context: None,
    };
    
    // TODO: Make this async when we have proper async runtime
    let command = tokio::runtime::Runtime::new()?.block_on(
        translation_engine.translate(request)
    )?;
    
    println!("Translated command: {}", command.command);
    
    let result = shell_executor.execute(&command)?;
    if result.success {
        println!("{}", result.output);
    } else {
        eprintln!("Error: {}", result.error.unwrap_or_else(|| "Unknown error".to_string()));
    }
    
    Ok(())
}

fn run_repl() {
    let mut rl = Editor::<(), DefaultHistory>::new().expect("Failed to create line editor");

    loop {
        let readline = rl.readline("[cmdr] ");

        match readline {
            Ok(line) => {
                // Add line to history
                let _ = rl.add_history_entry(line.as_str());

                // Handle non-empty lines
                if !line.trim().is_empty() {
                    println!("(REPL not yet implemented): {line}");
                }
            }
            Err(ReadlineError::Interrupted) => {
                // Ctrl-C: abort current line and continue
                println!();
                continue;
            }
            Err(ReadlineError::Eof) => {
                // Ctrl-D: exit cleanly
                break;
            }
            Err(err) => {
                eprintln!("Error: {err}");
                break;
            }
        }
    }

    // Clean exit
    process::exit(0);
}
