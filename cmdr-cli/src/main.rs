use clap::Parser;
use rustyline::error::ReadlineError;
use rustyline::history::DefaultHistory;
use rustyline::Editor;
use std::process;

/// cmdr - A fast, REPL-based command-line interface that translates natural language to shell commands
///
/// Phase 1 CLI Interface Contract:
///
/// Top-level flags (auto-generated by clap):
/// --help, -h     Display help information
/// --version, -V  Display version information
///
/// Phase 1 operational flags:
/// -c, --command <STRING>  Single-shot mode: translate and execute a single natural language command
/// --config <FILE>         Configuration file path (placeholder, not yet used in Phase 1)
///
/// Phase 2+ reserved functionality:
/// - Interactive REPL mode (default when no -c flag provided)
/// - Model selection and configuration options
/// - Inference backend selection (llama.cpp, mistral.rs, etc.)
///
/// Phase 3+ reserved functionality:
/// - Subcommands for advanced operations
/// - Plugin management
/// - History and session management
#[derive(Parser, Debug)]
#[command(
    name = "cmdr",
    version = env!("CMDR_VERSION"),
    author = "cmdr contributors",
    about = "A fast, REPL-based command-line interface that translates natural language to shell commands"
)]
struct Args {
    /// Single-shot mode: translate and execute a single natural language command
    #[arg(short = 'c', long = "command", value_name = "STRING")]
    command: Option<String>,

    /// Configuration file path (placeholder, not yet used)
    #[arg(long = "config", value_name = "FILE")]
    config: Option<String>,
}

fn main() {
    let args = Args::parse();

    // Fast-path execution logic for mature UNIX tool behavior

    // Handle -c/--command fast-path
    if let Some(_command) = args.command {
        println!("(command execution not yet implemented)");
        process::exit(0);
    }

    // Handle --config (placeholder for Phase 2)
    if let Some(config_file) = args.config {
        println!("Configuration file specified: {config_file}");
        // TODO: Implement configuration file parsing in Phase 2
        println!("Configuration loading not yet implemented");
    }

    // Interactive REPL mode
    run_repl();
}

fn run_repl() {
    let mut rl = Editor::<(), DefaultHistory>::new().expect("Failed to create line editor");

    loop {
        let readline = rl.readline("[cmdr] ");

        match readline {
            Ok(line) => {
                // Add line to history
                let _ = rl.add_history_entry(line.as_str());

                // Handle non-empty lines
                if !line.trim().is_empty() {
                    println!("(REPL not yet implemented): {line}");
                }
            }
            Err(ReadlineError::Interrupted) => {
                // Ctrl-C: abort current line and continue
                println!();
                continue;
            }
            Err(ReadlineError::Eof) => {
                // Ctrl-D: exit cleanly
                break;
            }
            Err(err) => {
                eprintln!("Error: {err}");
                break;
            }
        }
    }

    // Clean exit
    process::exit(0);
}
